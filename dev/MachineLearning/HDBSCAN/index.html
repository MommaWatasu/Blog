<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HDBSCANの仕組み · HorseBlog</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HorseBlog</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">FreeCraft</span><ul><li><a class="tocitem" href="../../FreeCraft/">最初に</a></li><li><a class="tocitem" href="../../FreeCraft/1st/">1回目</a></li></ul></li><li><span class="tocitem">HorseOS</span><ul><li><a class="tocitem" href="../../HorseOS/">HorseOSとは</a></li><li><a class="tocitem" href="../../HorseOS/mouse/">マウスを動かす</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>HDBSCANの仕組み</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HDBSCANの仕組み</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MommaWatasu/Blog/blob/master/src/MachineLearning/HDBSCAN.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="HDBSCANの仕組み"><a class="docs-heading-anchor" href="#HDBSCANの仕組み">HDBSCANの仕組み</a><a id="HDBSCANの仕組み-1"></a><a class="docs-heading-anchor-permalink" href="#HDBSCANの仕組み" title="Permalink"></a></h1><p>HorseMLの開発をしていて、リリースのお知らせをJuliaのDiscouseに書き込んだところ、HDBSCANやDBSCANのサポートを行う予定はありますか？との質問を受けたので、調べてみるとどうやらデータ密度からクラスを特定する手法のよう。つまり、K-meansのようにクラスタ数を最初に与えなくて良いのですが、この他にも、K-meansの拡張版であるX-meansでもBIC（ベイズ情報量）を用いてクラスタ数を決定する方法もあります。 DBSCANの実装はそう難しくなかったのですが、HDBSCANの理解・実装に時間がかかったので、備忘録として残します。</p><h2 id="HDBSCANのアルゴリズム"><a class="docs-heading-anchor" href="#HDBSCANのアルゴリズム">HDBSCANのアルゴリズム</a><a id="HDBSCANのアルゴリズム-1"></a><a class="docs-heading-anchor-permalink" href="#HDBSCANのアルゴリズム" title="Permalink"></a></h2><p>ほぼ、参考文献に載せた論文の2.2.2の文章を和訳したものです。</p><h3 id="中心距離の定義"><a class="docs-heading-anchor" href="#中心距離の定義">中心距離の定義</a><a id="中心距離の定義-1"></a><a class="docs-heading-anchor-permalink" href="#中心距離の定義" title="Permalink"></a></h3><p>このアルゴリズムには、対象となるデータの他に、２つのパラメータが必要となります。 １つ目のパラメータは距離の算出に使用する最小のポイントの数<code>k</code>です。もう一つは、クラスタの形成に必要な最小のクラスタサイズ<code>min_clusters</code>です。 最初のステップはデータ同士の距離を求めることです。まず、それぞれの点について中心距離を定義します。中心距離は、「ある点からk番目に近い点からの距離」として定義されます。</p><p>この中心距離を用いて、相互到達可能距離(mutual reachability distance)と呼ばれる新しい測定基準が計算できます。相互到達可能距離は、2点それぞれの中心距離と2点間の距離（ユークリッド距離）の最大値です。</p><h3 id="最小全域木"><a class="docs-heading-anchor" href="#最小全域木">最小全域木</a><a id="最小全域木-1"></a><a class="docs-heading-anchor-permalink" href="#最小全域木" title="Permalink"></a></h3><p>次に、相互到達可能距離はデータ点を頂点として持ち、どの2点の間のエッジも相互到達可能距離の重みを持つグラフを作成するのに使用できます。これは計算する必要のあるグラフの最小全域木なので、アルゴリズムの人工的な概念に過ぎません。最小全域木とは全域木のエッジの重みの合計が最小になるものです。 つまり、最小全域木は閉路を持たず、エッジの重みの合計が最小となる完全なグラフに含まれるエッジによってすべてのノードが連結されたものです。結果の最小全域木はそれぞれの相互到達可能距離を重みとするループ（self-edge,loopとも呼ばれます）を各頂点に加えることで変更されます。これにより拡張最小全域木と呼ばれるものが得られます。</p><p>これで、グラフを使用してHDBSCAN階層を構築できます。 まず、クラスターラベルが1つあり、すべてのポイントがこのクラスターに割り当てられます。 このクラスターはクラスターリストに追加されます。 次に、グラフはエッジの重みで昇順で並べ替えられます。グラフの下から順に、拡張された最小スパニングツリーからエッジが繰り返し削除されます。同じ重みのエッジも同時に削除する必要があります。削除されるエッジの重み値は、現在の階層レベルを示すために使用されます。エッジが削除されると、削除されたエッジを含むクラスターが探索されます。切断され、 <code>min_size</code>より少ないポイントを含むクラスターには、すべてノイズラベルが割り当てられます。 切断されたが<code>min_size</code>ポイントを超えるクラスターには、新しいクラスターラベルが割り当てられます。 これはクラスター分割と呼ばれます。更に、新しいクラスタはクラスタのリストに追加されます。エッジの削除によるクラスタ分割が原因で新たなクラスタが生成された時に、新たな階層レベルが作られます。最終的には、データセットに含まれるすべてのデータがノイズに割り振られます。このような過程によって作られた階層がHDBSCAN階層です。HDBSCAN階層を作成する間、すべてのクラスタは保持され、それぞれの親クラスタへの参照を持っています。</p><h3 id="クラスタの識別"><a class="docs-heading-anchor" href="#クラスタの識別">クラスタの識別</a><a id="クラスタの識別-1"></a><a class="docs-heading-anchor-permalink" href="#クラスタの識別" title="Permalink"></a></h3><p>次のステップでは、HDBSCAM階層と作成されたクラスタのリストを使って特徴的なクラスタを階層の中から識別することです。これを行うには、クラスタの安定性を決定するのに使うことのできる新たな基準が確立される必要があります。これはラムダと呼ばれ、<span>$\lambda = \frac{1}{edgeweight}$</span>というものです。更に、クラスタにも<span>$\lambda_{birth}$</span>と<span>$\lambda_{death}$</span>をそれぞれクラスタが生成された時のラムダ、そのクラスタが2つのクラスタに分割された際のラムダとして定義します。クラスタ内のそれぞれの点には、その点がクラスタから落ちた時のラムダを<span>$\lambda_{p}$</span>として定義できます。これで安定性をクラスタに対して計算することができます。このように表現できます。</p><p class="math-container">\[stability = \sum_{p \in Cluster}(\lambda_{p} - \lambda_{birth})\]</p><p>この安定性はクラスタを通して伝播される必要があります。末端のクラスタは子クラスタを持たず、クラスタのリストから識別することができます。末端のクラスタから始めてクラスタの持つ参照を用いて上の階層のクラスタへと移って行きます。末端のクラスタは常にその安定性を親クラスタに伝播するともに伝搬された子クラスたとして親クラスタに追加します。末端でないクラスタには2つのうちどちらかが起こります。もし処理中のクラスタの安定性が子クラスタの合計安定性より高い場合、その安定性だけが親クラスタへ伝えられます。その他の場合、その子クラスタの安定性の合計が親クラスタに伝えられます。自明ですが、ルートクラスタでは親クラスタへの伝播は発生しません。 処理が終わると、ルートクラスタには安定性が最も高い子クラスタへの参照が含まれています。最も高い安定性を持つクラスタは最も特徴的なクラスタです。最も特徴的なクラスタの詳細とともにHDBSCAN階層を使用すると、各データポイントのクラスタ割当が高速に生成できます。</p><h2 id="最後に"><a class="docs-heading-anchor" href="#最後に">最後に</a><a id="最後に-1"></a><a class="docs-heading-anchor-permalink" href="#最後に" title="Permalink"></a></h2><p>大分複雑なので、「ん？」となるところも結構ありますが、なんとか理解できるかなって感じです。 難しいアルゴリズムではありますが、他の手法とは段違いにノイズに強いので役に立つものだと思います（けどHorseMLに実装するのはかなり骨が折れそう…）。</p><h2 id="参考文献"><a class="docs-heading-anchor" href="#参考文献">参考文献</a><a id="参考文献-1"></a><a class="docs-heading-anchor-permalink" href="#参考文献" title="Permalink"></a></h2><ul><li><a href="https://www.mdpi.com/2076-3417/12/5/2405">An Implementation of the HDBSCAN* Clustering Algorithm</a></li><li><a href="https://hdbscan.readthedocs.io/en/latest/how_hdbscan_works.html">How HDBSCAN Works</a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Sunday 27 March 2022 13:40">Sunday 27 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

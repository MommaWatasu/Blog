var documenterSearchIndex = {"docs":
[{"location":"HorseOS/memory/#メモリ管理ぐらいまで","page":"メモリ管理","title":"メモリ管理ぐらいまで","text":"","category":"section"},{"location":"HorseOS/memory/#ブートローダーの修正","page":"メモリ管理","title":"ブートローダーの修正","text":"","category":"section"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"uefi-rsのドキュメントを見ていて気づきました。他の人がだいぶ前に作ったOSのCargo.tomlを見ていたので、uefi-rsのバージョンがかなり古くなっていました。 古いものを使い続けるのは厄介なので、ここでコードのリファクタリングも兼ねてブートローダーをuefi-rs18.0を使って書き直しました。 ついでに、yubrotさんのorsを参考に、ELFのロード方法なども変更しました。","category":"page"},{"location":"HorseOS/memory/#メモリ管理","page":"メモリ管理","title":"メモリ管理","text":"","category":"section"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"正直、ここは割と作業なので、あんまり考える余地がないので、できてるものをコピるのが早いと思います。 というわけで、メモリ管理は完成〜としたいところでしたが、なぜか動きません。正確には実機ではちゃんと起動してくれるのですが、QEMUで実行するとフリーズします。","category":"page"},{"location":"HorseOS/memory/#エントリポイントの修正","page":"メモリ管理","title":"エントリポイントの修正","text":"","category":"section"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"これの原因究明にはかなり時間を使いましたが、メモリマップとブートローダを見直した結果わかりました。 おそらく（解決後もはっきりとは分かってない）カーネルのベースアドレスを指定していなかったために、後ろの方のアドレスにカーネルが配置されてしまい、他のシステムが使うメモリを破壊してしまったようです。 なので、少し気持ち悪いですが、Rustのターゲットファイルx86_64-unknown-none-horsekernel.jsonにあるpost-link-argsでイメージのベースアドレスを指定するオプションを追加します。 こんな感じです：","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"...\n\"post-link-args\": {\n    \"ld\": [\n        ...\n        \"--image-base=0x100000\"\n        ...\n    ]\n}\n...","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"正直、未だにこのターゲットファイルのそれぞれのパラメータの意味が理解できていません。そろそろなんとかしたいな… では、再度実行してみましょう。どうなったでしょうか？多分相変わらずフリーズします。さっきの設定で追加で0x100000~0x200000が使えるようになったのは事実なんですが、それでもカーネルのプログラムサイズが0xa00000もあるので、メモリマップの都合上収まりません。 更に、確認のためyubrotさんのorsを実行して確認したところ、本来のカーネルサイズは0x700000ほどなようなので、なにか他のプログラムに問題があるようです。 ここまで来るとELFのファイル構造を勉強したほうがいいと思ったので、一度ここで説明しようと思います。","category":"page"},{"location":"HorseOS/memory/#ELFファイルの構造","page":"メモリ管理","title":"ELFファイルの構造","text":"","category":"section"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"ELFファイルは主に3つの部分からなります。以下のような構造です。","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"+----------------+\n|   ELF Header   |\n+----------------+\n| Program Header0|\n| Program Header1|\n|       :　　　　 |\n+----------------+\n|    Segment0    |\n|    Segment1    |\n|       :　　　　 |\n+----------------+","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"HorseOSのブートローダーは現状goblinというRustのクレートにELFファイルの解析を丸投げしてますが、本来は先頭にあるELFヘッダからELFのメタデータを取得した後、プログラムから各セグメントに対応する（つまり、プログラムヘッダはセグメントと同数存在する）情報を取得し、これをもとにメモリのどこにプログラムをロードするかを決定します。 そして、それぞれのセグメントについてですが、セグメントは主に","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"コードセグメント\nデータセグメント","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"の2種類があります。その名と通りコードセグメントはプログラムがマシン語で記述されており、データセグメントはプログラムが使用するデータ（staticやconstで宣言された変数）を保持しています。","category":"page"},{"location":"HorseOS/memory/#原因のデータ","page":"メモリ管理","title":"原因のデータ","text":"","category":"section"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"先程のELFの構造が分かった上で、ブートローダでファイル経由でELFのプログラムヘッダの情報を表示してみました。","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"start: 1048576, end: 1104092\nstart: 1108192, end: 1441923\nstart: 1446024, end: 1446032\nstart: 1454080, end: 11190352\nstart address is: 00100000\nend address is: 00aac050\nkernel_size: 009ac050","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"これは僕が実際にデバッグするために表示したデータです（どこに原因があるのかわからず余計な情報も表示しています）。そして、これをメモリマネージャなしの状態で表示すると","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"start: 1048576, end: 1103260\nstart: 1107360, end: 1436739\nstart: 1440840, end: 1440848\nstart: 1445888, end: 6987856\nstart address is: 00100000\nend address is: 006aa050\nkernel_size: 005aa050","category":"page"},{"location":"HorseOS/memory/","page":"メモリ管理","title":"メモリ管理","text":"おわかりでしょうか？明らかに最後のセグメントのデータ数だけ大きく差があり、また一番データを食ってるのも一番最後のセグメントです。つまり、おそらく最後のセグメントがデータセグメントとなっています。載せるのが面倒なので書きませんが、orsでこれを確認すると、更にデータセグメントの部分が少なくなっています。しかも、興味深いことにちょうどBitmapFrameManagerと同じだけ！後は片っ端からカーネルで宣言されているグローバル変数を確かめていくだけです。 すると、なんとなく察していましたが、USB用にメモリアロケータを作成していることに気づきました。こちらは4MB分のメモリアロケータを実装していたため、BitmapFrameManagerのビットマップと同じだけ消費していたようです。 ここまでわかれば後はこいつを新しく実装した動的アロケータで置き換えればいいわけです。めでたしめでたし。 次回からはようやくウィンドウなんかの実装へと移ります！","category":"page"},{"location":"AGI/CorticalColumn/#このドキュメントについて","page":"大脳皮質","title":"このドキュメントについて","text":"","category":"section"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"私の最終的な目的は、脳について知ることではなく、それをリバースエンジニアリングすることによる、知的機械の作成です。 このドキュメントはWikipediaを翻訳して作成しました。","category":"page"},{"location":"AGI/CorticalColumn/#皮質コラム","page":"大脳皮質","title":"皮質コラム","text":"","category":"section"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"皮質コラムは大脳皮質で皮質面に対し垂直な円筒形の構造をとるニューロンのグループです。この構造は1957年にマウントキャッスルによって初めて発見されました。彼は後に新皮質の基本単位としてコラムに並べられたミニコラムを発見しました。各コラムは同じタイプのニューロン、接続、発火特性を持ちます参考文献。コラムはハイパーコラム、マクロコラム、機能コラム、時には皮質モジュールと呼ばれます。ミニコラム（マイクロコラム）内のニューロンは類似の特徴を符号化するが、一方でハイパーコラムは「任意の与えられた感覚野パラメータの集合の価値の完全な集合を含む単位を示す」参考文献。皮質モジュールはハイパーコラムと同様に定義されるか、複数の重なり合うハイパーコラムの組織ブロックとして定義されます。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"皮質コラムは予測コーディング（predictive coding、補足を参照）のための正規の小型回路であることが提唱されており、認知の処理は同一の小型回路の階層を通して実装されます。 この複製に対する進化上の利益は、人間の新皮質がこの300万年のうちに約3倍まで増大することを可能にしました。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"柱状仮説は皮質が、一貫した接続プロファイルを特徴とニューロンの離散的なモジュールコラムで構成されていると主張します。 この説は現在、脳の情報処理の説明に最も広く引用されています。","category":"page"},{"location":"AGI/CorticalColumn/#哺乳類の脳皮質","page":"大脳皮質","title":"哺乳類の脳皮質","text":"","category":"section"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"哺乳類の脳皮質、白質を包んでいる灰白質は層で構成されています。人間の大脳皮質は2~3mmの厚さです。層数はほとんどの哺乳類で同じですが、皮質全体では異なります。新皮質では6つの層が認識できますが、多くの領域で1つ以上の層が欠落しており、旧皮質(archipallium)や古皮質(paleopallium)では、さらに層の数が少なくなります。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"柱状機能組織","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"ヴァーモン・マウントキャッスルによって初めて枠組みが作られた参考文献、柱状機能組織は水平方向に0.5mm(500μm)以上離れたニューロンは感覚受容場を共有しないことを示唆しており、他の実験結果でも200~800μmの似たような結果が示されている。 様々な試算で、50から100個のミニコラムが一つのハイパーコラムの中にあることが示唆されており、各ミニコラムは約80個のニューロンを含みます。 柱状機能組織は「情報処理の単位機能」としてよく理解されます。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"重要な違いは柱状組織はは定義上機能的であることで、大脳皮質の局所的な接続を反映します。皮質の厚みの中の上下の接続は、側面から側面へと広がる接続に比べ、はるかに密です。","category":"page"},{"location":"AGI/CorticalColumn/#ヒューベルとウィーゼルの研究","page":"大脳皮質","title":"ヒューベルとウィーゼルの研究","text":"","category":"section"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"デビッド・ヒューベルとトーステン・ウィーゼルはマウントキャッスルの体性感覚皮質についての発見を彼らの視覚に関する研究の中で追求した。 1981年にノーベル賞を受賞した発見は、視覚野にも皮質コラムがあり、近隣のコラムは最大放電を起こした線の向きの観点から機能的に関連しているというものでした（後者はいまいち意味が分かりませんでした）。 彼らは自分たちの研究について、環境の変化の皮質組織に与える影響について論証する研究の中で追求し、これらの研究の結果としてノーベル賞を受賞しました。","category":"page"},{"location":"AGI/CorticalColumn/#皮質コラムの数","page":"大脳皮質","title":"皮質コラムの数","text":"","category":"section"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"人間の新皮質の中には約2億の皮質ミニコラムが存在し、それぞれが最大約110個のニューロンを持ち、新皮質の中には210〜260億のニューロンがあると推定されています。 各皮質コラムは50〜100の皮質ミニコラムを持ち、人間の脳は200〜400万の皮質コラムを持ちます。 角田らの提案のように、コラムが重複しうるのであれば、皮質コラムはより多く存在するだろう。ジェフ・ホーキンスは彼のヌメンタでの研究に基づき、人間の新皮質には15万個の皮質コラムしかないと主張します（彼の「A Thousand Brains: New theory of intelligence」は非常に興味深い本です）。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"ミニコラムは400個の重要な細胞を持つ可能性があるという主張があります。ただし、これがグリア細胞を含むものかは不明確です。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"元の研究が恣意的すぎるとして、前述の推定を否定する研究者もいます。著者は同一の新皮質を提案し、細胞の数を計算するのに固定された横幅と長さを選んでいます。後の研究で、確かに新皮質は種族間で均一ではないことが指摘され、9種の霊長類を研究することで「皮質表面下の1㎟のニューロンの数は、種族間で3倍変化する」ことが分かりました。新皮質は種族間で同一のものではないんです。 実際の単一のコラム内のニューロンの数は可変であり、それは脳の領域、つまりは機能に依存します。","category":"page"},{"location":"AGI/CorticalColumn/#補足","page":"大脳皮質","title":"補足","text":"","category":"section"},{"location":"AGI/CorticalColumn/#Predictive-coding","page":"大脳皮質","title":"Predictive coding","text":"","category":"section"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"予測コーディングとは、脳が絶えず環境の「精神モデル」を作成し、更新することを仮定する脳機能の理論です。この精神モデルは感覚からの入力信号を予測するのに使用され、界の生成モデルに関する予測誤差を最小化するために、予測結果は実際の入力信号と比較されます。","category":"page"},{"location":"AGI/CorticalColumn/","page":"大脳皮質","title":"大脳皮質","text":"この理論はベイズ脳フレームワークと密接に関係しており、直近20年にわたって理論神経学や認知神経学に対する実質的な影響力を得ました。","category":"page"},{"location":"AGI/#AGIについて","page":"AGIについて","title":"AGIについて","text":"","category":"section"},{"location":"AGI/","page":"AGIについて","title":"AGIについて","text":"そもそも、皆さんはAGIという言葉に馴染みがあるでしょうか？AIは「Artificial Intelligence」つまりは人工知能として良く聞きますが、AGIは2023年現在ではそれほど頻繁に使われてはいません。 AGIは「Artificial General Intelligence」つまりは汎用人工知能の略です。なぜ、機械学習とは別のテーマにしているかと言うと、私は一般にAIと呼ばれるものは機械学習の延長である一方、AGIはより脳科学と融合したものであると考えているためです。","category":"page"},{"location":"AGI/","page":"AGIについて","title":"AGIについて","text":"もともと、AIは回帰曲線などを使って、数値的な予測を行う機械学習として発展しました。しかし、ここに脳のニューロンのような構造をとりいれることにより、人間を凌駕する性能が出せることが分かり、今日のAIに至ります。 確かに、ChatGPTのような大規模言語モデルは既に人間と同じように考えているように見えますが、本質的に異なると考えています。なぜならこういったLLM(Large Language Model)は、論理処理の代わりに確率処理を行っており、原理的には已然からあるパターン認識と大きくは違いません。","category":"page"},{"location":"AGI/","page":"AGIについて","title":"AGIについて","text":"一方のAGIは「脳のリバースエンジニアリング」によって生み出されるものであると考えています。もちろん、AGIが最終的にどのようなアルゴリズムで動くか断言することはできませんし、現に進化的アルゴリズムなど他のアプローチも存在しますが、それでも私はこの方法が正しいと考えます。 一番の理由は、もし今あるAIを進化させるにせよ、進化的アルゴリズムにせよ、結果的に得られる機械知能は人間と同様の思考回路ではないため、人間がそれを理解するのも困難になると考えられるためです。","category":"page"},{"location":"AGI/#AGIの研究について","page":"AGIについて","title":"AGIの研究について","text":"","category":"section"},{"location":"AGI/","page":"AGIについて","title":"AGIについて","text":"前述したように、私はあくまでAGIは脳の神経細胞の仕組みを詳細まで理解し、それをソフトウェアで再現することで初めて作ることができると考えています。 したがって、このテーマで書いているブログの中には脳についてのものが多く含まれます。 むしろ、脳についてある程度の知識がなければそれをリバースエンジニアリングすることもできませんから、少なくとも東雲は脳・神経科学についてのブログとなると思います。","category":"page"},{"location":"FreeCraft/1st/#FreeCraft作成一回目(2022/3/17)","page":"1回目","title":"FreeCraft作成一回目(2022/3/17)","text":"","category":"section"},{"location":"FreeCraft/1st/#準備","page":"1回目","title":"準備","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"まずは使う言語を決めることになるわけなんですが、まあ、ゲームなのでコンパイル言語のほうがいいだろうということで、Rustにしました（基本的にC系は好きじゃないので、勉強してないので）。 そんで、Rustには3D描画できるライブラリというのはPiston、Amethyst、RG3Dと言った選択肢があるんですが、PistonはDocsがよくわからず、Amethsyはバグがあるのに、レポジトリが「InActivity Mainteined」となっていて、ダメそう。ということでRG3Dを使って作っていきます。","category":"page"},{"location":"FreeCraft/1st/#とりあえずプロジェクトを作成","page":"1回目","title":"とりあえずプロジェクトを作成","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"とりあえずCargoでプロジェクトを作ります。","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"$ cargo new FreeCraft --bin","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"そんで、Cargo.tomlを書いておきます。","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"[package]\nname = \"freecraft\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nfyrox = \"0.24.0\"","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"そしてとりあえずcargo buildするわけなんですが、多分一発では通りません（通ったら運が良いと思います）。","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"まずはここで出るコンパイルエラー達をさばきましょう(申し訳ないんですが、ここはあんまり記録撮ってないので記憶で書きます)。","category":"page"},{"location":"FreeCraft/1st/#alsaに関するエラー","page":"1回目","title":"alsaに関するエラー","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"筆者はこれでまず一回コンパイルが止まったんですがalsaなるパッケージがないよ、みたいなエラーで止まる症状が出ることがあります。 これは冷静にalsaをaptで入れてやりましょう。","category":"page"},{"location":"FreeCraft/1st/#error:-linking-with-cc-failed:-exit-code:-1","page":"1回目","title":"error: linking with cc failed: exit code: 1","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"こいつはなんか大量のエラーが図れるので気が滅入りますが、こういうとてつもないエラーは最後が肝心。 1つ目のnoteを無視して、2つ目のnoteを見てみるとcannot find ~みたいに書いてあると思います。この~の部分の頭は代替lで始まってるんですが、このlのあとをapt list | grep ~して、devってついてる物を見つけてインストールしてやりましょう。","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"多分ここまででRG3Dのコンパイルが通るとこまでは行ったと思います。次はとりあえず3D描画します。","category":"page"},{"location":"FreeCraft/1st/#Hello-World","page":"1回目","title":"Hello World","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"じゃあRG3Dの使い方を説明しよう！ってことになるんですが、結構コードが長くてコードとともに解説するのは難しいので、大体の説明は公式チュートリアルを見てもらうことにして、補足的な説明をします。","category":"page"},{"location":"FreeCraft/1st/#ブロックを表示したい","page":"1回目","title":"ブロックを表示したい","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"ブロックを表示するのには、手続き型（プログラムで記述する）方法と3Dモデルをロードする方法があります。最初は手続き型の方が何かと便利だと思っていたのですが、やってみると各面に異なるテクスチャを貼ることができないようなんです。あと、3Dモデルの方が何かと編集するのとかが便利なので、3Dモデルを予めBlenderで作っておいて、それをロードするようにします。 ここで注意点があります、チュートリアル通りにメッシュを作成しただけではブロックを自分が透過してしまいます。これを解決するには、ブロックのメッシュにColliderと呼ばれるものを設定する必要があります。これにより、メッシュに当たり判定が作られ、近づくと、カメラのColliderとぶつかって透過しなくなります。 また、マイクラでは重力に従うブロックと従わないブロックがありますが、RigidBodyにはデフォルトで重力などが働くため、外部からの力によって動かないようにRigidBodyTypeとしてStaticを指定してやる必要があります。","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"ここまでの内容を考慮して、以下のような関数を作りました。","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"async fn load_model_to_scene(\n    scene: &mut Scene,\n    path: &str,\n    resource_manager: &ResourceManager,\n    position: (f32, f32, f32)\n) -> Handle<Node> {\n    // Request model resource and block until it loading. \n    let model_resource =\n        resource_manager.request_model(Path::new(&path))\n            .await\n            .unwrap();\n\n    RigidBodyBuilder::new(\n        BaseBuilder::new()\n            .with_local_transform(\n                TransformBuilder::new()\n                    // Offset player a bit.\n                    .with_local_position(Vector3::new(position.0, position.1, position.2))\n                    .build(),\n            )\n            .with_children(&[\n                // Create an instance of the resource in the scene. \n                model_resource.instantiate_geometry(scene),\n                // Add capsule collider for the rigid body.\n                ColliderBuilder::new(BaseBuilder::new())\n                    .with_shape(ColliderShape::cuboid(0.25, 0.25, 0.25))\n                    .build(&mut scene.graph)\n            ]),\n    )\n    // We don't want the player to tilt.\n    .with_locked_rotations(true)\n    // We don't want the rigid body to sleep (be excluded from simulation)\n    .with_can_sleep(false)\n    // We don't want the block to move\n    .with_body_type(RigidBodyType::Static)\n    .build(&mut scene.graph)\n}","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"この関数はpositionにx座標、y座標、z座標のタプルを渡すと、指定した座標に土ブロックを表示してくれます。","category":"page"},{"location":"FreeCraft/1st/#テクスチャの修正","page":"1回目","title":"テクスチャの修正","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"先程のコードでブロックの描画自体はできるんですが、元画像が16ピクセルなので、テクスチャがぼやけます。では、ぼやけるのを治すのにはどうしたらいいかというと、テクスチャを読み込む際のオプションを*.png.optionにかけるので、ここで修正するように設定しておきます。 このようにしてください","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"(\n    minification_filter: Nearest,\n    magnification_filter: Nearest,\n    s_wrap_mode: Repeat,\n    t_wrap_mode: ClampToEdge,\n    anisotropy: 8.0,\n    compression: NoCompression,    \n)","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"このうち、","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"minification_filter: Nearest,\nmagnification_filter: Nearest,","category":"page"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"が重要です。これによりテクスチャを読み込むときに勝手に修正してくれます。","category":"page"},{"location":"FreeCraft/1st/#最後に","page":"1回目","title":"最後に","text":"","category":"section"},{"location":"FreeCraft/1st/","page":"1回目","title":"1回目","text":"今回はどうやってブロックを描画するのかまでを書きました。次回は今ある当たり判定の不自然さを直して、ブロックをバリエーションを増やしてそれっぽくしていこうと思います。","category":"page"},{"location":"FreeCraft/#FreeCraft","page":"最初に","title":"FreeCraft","text":"","category":"section"},{"location":"FreeCraft/","page":"最初に","title":"最初に","text":"ゲームプログラミングをやってみたいなーと思って、どんなゲームを作ろうか考えたんですが、せっかくなら3Dゲームがいい、それならMinecraftかなーと言うことで自作してみることにしました。","category":"page"},{"location":"FreeCraft/#目次","page":"最初に","title":"目次","text":"","category":"section"},{"location":"FreeCraft/","page":"最初に","title":"最初に","text":"Pages = [\n    \"FreeCraft/1st.md\"\n]\nDepth = 1","category":"page"},{"location":"HorseOS/mouse/#マウスを動かすまで","page":"マウスを動かす","title":"マウスを動かすまで","text":"","category":"section"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"Mikan本持ってない方でもわかるようHello Worldは書いておきます。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"まず、「OSを作る」と言われても、どう動くものかイメージがつかないとやってられないと思います。大雑把な流れとしては、","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"BIOSがIPL(Initial Program Loader)を呼び出す。こいつはUSBメモリの中の/EFI/BOOT/BOOTX64.efiであることになってる。\nIPLがUEFIのboot service(標準出力などを一時的に提供してくれる)を使ってメモリマップの書き込みを行う\nIPLからカーネルを呼び出す。このときUEFIは邪魔にならないよう切っておく。\nカーネルが動き始める。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"といった感じです。Hello Worldやったあとは、ちょっと長くなる（そしてIntelのおじさんが決めたからシリーズ）ので、マウスを動かすまで若干省きます。","category":"page"},{"location":"HorseOS/mouse/#Hello-World","page":"マウスを動かす","title":"Hello World","text":"","category":"section"},{"location":"HorseOS/mouse/#準備","page":"マウスを動かす","title":"準備","text":"","category":"section"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"Hello Worldするのにも準備が必要です（なんだかんだここが一番つまんない気がします）。 まず、Rustの最新バージョンを使う必要があるので、rustup default nightlyしておきます。 そして、リンクにLLVMが後々必要になるので入れちゃいます。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ sudo apt install lld","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"テスト環境としてQEMUを使いたいので、インストールします。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ sudo apt install qemu\n$ sudo apt install qemu-utils\n$ sudo apt install qemu-system-x86","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"更に、QEMUを動かすのにOVFMなるファイルが必要になるのですが、面倒くさいので僕のリポジトリの/dev-toolsから持ってきてください（両方です）。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"また、Rustも発達途中で、いろいろエラーが出るかもしれませんが、そのときはコンパイラのnoteやらhelpを見ましょう。Rustのコンパイラは本当に親切です。","category":"page"},{"location":"HorseOS/mouse/#IPL","page":"マウスを動かす","title":"IPL","text":"","category":"section"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"準備は先ほどしたんですが、Cargoの設定はまだ残っています。 まずプロジェクトを作って","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ cargo new [ブートローダのプロジェクト名] -bin","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"Cargo.tomlをこんな感じに（適宜読み変えてください）します。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"[package]\nname = \"horse-bootloader\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nuefi = { version = \"0.10.0\", features = [\"exts\", \"alloc\", \"logger\"] }\nlog = { version = \"0.4.11\", default-features = false }\nelf_rs = \"0.1\"","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"更に.cargo/config.tomlをこんな感じで","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"[build]\ntarget = \"x86_64-unknown-uefi\"\n\n[unstable]\nbuild-std = [\"core\", \"alloc\", \"compiler_builtins\"]\nbuild-std-features = [\"compiler-builtins-mem\"]","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"これでやっと本題です。IPLのプログラム(src/main.rs)をこんな感じで書いてください","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"#![feature(abi_efiapi)]\n#![feature(alloc_error_handler)]\n#![no_std]\n#![no_main]\n\n#[macro_use]\nextern crate alloc;\nuse alloc::string::ToString;\nuse core::arch::asm;\nuse console::gop;\nuse log;\nuse core::fmt::Write;\nuse elf_rs::*;\nuse proto::console;\nuse uefi::{\n    prelude::*,\n    proto::{self, console::gop::GraphicsOutput, media::fs::SimpleFileSystem},\n    table::boot::{EventType, MemoryDescriptor, Tpl},\n};\nuse uefi::{\n    proto::media::file::{File, FileAttribute, FileInfo, FileMode, FileType::Regular},\n    table::boot::{AllocateType, MemoryType},\n};\n\nstatic mut LOGGER: Option<uefi::logger::Logger> = None\n\n#[entry]\nfn efi_main(handle: Handle, st: SystemTable<Boot>) -> Status {\n    let bt = st.boot_services();\n    let stdout = st.stdout();\n    \n    writeln!(stdout, \"booting HorseOS...\").unwrap();\n}","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"これで","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ cargo build","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"して、target/x86_64-unkown-uefi/debugからEFIファイルを持ってきます。 ここから黙々とコマンドを叩いていけばHello Worldと出会えるはず。。。（だめだったらここは他のサイト見てください、だいぶ立ってから書いてるので記憶が薄れてるので）","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ qemu-img create -f raw disk.iso 200M\n$ mkfs.fat -n 'HORSE OS' -s 2 -f 2 -R 32 -F 32\n$ mkdir -p mnt\n$ sudo mount -o loop disk.iso mnt\n$ sudo mkdir -p mnt/EFI/BOOT\n$ sudo cp bootloader.efi  mnt/EFI/BOOT/BOOTX64.EFI\n$ sudo umount mnt\n$ qemu-system-x86_64 \\\n    -m 1G \\\n    -drive if=pflash,format=raw,readonly,file=./dev-tools/OVMF/OVMF_CODE.fd \\\n    -drive if=pflash,format=raw,file=./dev-tools/OVMF/OVMF_VARS.fd \\\n    -drive if=ide,index=0,media=disk,format=raw,file=disk.iso \\\n    -device nec-usb-xhci,id=xhci \\\n    -device usb-mouse -device usb-kbd \\\n    -monitor stdio \\","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"ふう、こんな画面が見えましたか？ (Image: Hello World) まあ、ここは感動するための手続きみたいなもんなので、駄目なら駄目でさっさと次に進んでしまいましょう。 なお、僕のようにお馬鹿な人ばかりではないと思いますが、QEMUの画面でマウスをキャプチャして「抜け出せない！」などとならないようにしましょう、ダサすぎるので。Windowのタイトルに書いてありますが、Ctrl+Alt+Gで抜けられます。","category":"page"},{"location":"HorseOS/mouse/#カーネルを呼び出してみよう","page":"マウスを動かす","title":"カーネルを呼び出してみよう","text":"","category":"section"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"面倒くさいのでIPLの詳細は省きます。興味のある人はコードを読んだり他のサイトを探してください（カーネル本体書き始めるまではほんとにやるだけです）。 というわけでIPLを僕のリポジトリから引っ張って来て、魔改造してあげましょう。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"そして、カーネルのテンプレも作りましょう（OSの名前はよく考えましょう、愛着の湧くように）。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ cargo new [OSの名前] -bin","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"そして、カーネルのビルドはIPLよりひと手間増えます。僕のリポジトリからターゲットファイルを取って来て、プロジェクト直下に置いといてください。 そしてCargo.tomlを","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"[package]\nname = \"horse-kernel\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nx86_64 = \"0.14.1\"\nspin = { version = \"0.9.0\", features = [\"lock_api\", \"mutex\"] }\n\n[profile.dev]\npanic=\"abort\"","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":".cargo/config.tomlを","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"[build]\ntarget = \"x86_64-unknown-none-horsekernel.json\"\n\n[unstable]\nbuild-std = [\"core\", \"compiler_builtins\"]\nbuild-std-features = [\"compiler-builtins-mem\"]","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"こうして準備完了です。src/main.rsにカーネルの土台を書きます。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"#![no_std]\n#![no_main]\n#![feature(abi_efiapi)]\n\n#[no_mangle]\nextern \"sysv64\" fn kernel_main(fb: *mut FrameBuffer, mi: *mut ModeInfo) -> ! {\n    loop {\n        unsafe {\n            asm!(\"hlt\")\n        }\n    }\n}","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"とりあえずCPUを休ませるだけですが、ひとつだけ説明する必要があるのは、extern \"sysv64\"ですが、Rustでプログラムを書くと、余計な情報がついてしまうようで、そのままだとIPLが上手くこの関数を呼び出せません、そこで、Cのように不要なものの内容にするために指定しています。 このあとプログラムを読めば解ると思いますが、ところどころCに合わせるために細工がされています。","category":"page"},{"location":"HorseOS/mouse/#マウスを動かそう","page":"マウスを動かす","title":"マウスを動かそう","text":"","category":"section"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"マウスを動かすまでにいろいろあるんですが、こういう技術的な解説を書こうとするとまさにMikan本のようなものすごく長いものになってしまうので、大幅カットで一気にマウスを動かすところまで行きます。 で、ちょっとこっから先はコードが長いので、GitHubからcloneしてください。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ git clone https://github.com/MommaWatasu/Horse.git","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"そして、マウスを動かすためにチェックアウトします。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ git checkout ba6648e","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"だいぶいろいろ追加されてますが、だいたいこんなものが追加されてます。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"dev-tools: ビルド関係のファイル\nMakefile.toml: Cargo-makeの設定ファイル、こいつのおかげであの冗長なコマンドを打たなくて済む。入れてない人はCargo-makeを入れておきましょう。\nkernel: カーネルとその他愉快な仲間たち(usbディレクトリにUSB ホストドライバが入ってます。)","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"説明が面倒くさいのでこれ以上の説明はしませんが、なんとなく一度コードを眺めて何をしているのかぐらいは見ておいた方がいいと思います。僕も他の方のコードを眺めて大体関係性をりかいしたので。ファイル名から何やってるか察する事も多いと思いますしね。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"さて、皆さんお待ちかねのマウス君とキーボード君の登場です。","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"$ makers RUN","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"するとあら不思議、マウスがちゃんと動き、キーボードも入力した文字が表示されるではありませんか！ Mouse and Keyboard これは感動しましたよ。こういうの見ると、開発し続けるやる気が湧いてきます。 ただ、お気づきかと思いますが、マウスが端に寄せたときに隠れないなどの不自然なところはありますが、このへんは少し面倒なので後回し。","category":"page"},{"location":"HorseOS/mouse/#おまけ","page":"マウスを動かす","title":"おまけ","text":"","category":"section"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"実機で動かしているの図、古いパソコンと古いUSBがあったらぜひやってみてください、LinuxのUSBライタでdisk.isoを書き込んで、BIOSでセキュアブートをオフにした上で起動順位さえ変えれば簡単にできます。 (Image: real-machine)","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"XHCIの設定周りのテストをしているの図、この辺はMikan本を読みながらやれるといいです。 (Image: XHCI)","category":"page"},{"location":"HorseOS/mouse/","page":"マウスを動かす","title":"マウスを動かす","text":"ビルドのビフォーアフター、僕はホストドライバをmandarinOSという他の方が書いたものから取ってきたんですが（先人は偉大）、これの写経をしていて、大量のバグが出ました。前と後のスクロールバーの大きさでわかるかと思います。。。みなさんもOS作りをするときは無理そうならコピペしましょう。 (Image: build)","category":"page"},{"location":"MachineLearning/HDBSCAN/#HDBSCANの仕組み(2022/3/29)","page":"HDBSCAN","title":"HDBSCANの仕組み(2022/3/29)","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"HorseMLの開発をしていて、リリースのお知らせをJuliaのDiscouseに書き込んだところ、HDBSCANやDBSCANのサポートを行う予定はありますか？との質問を受けたので、調べてみるとどうやらデータ密度からクラスを特定する手法のよう。つまり、K-meansのようにクラスタ数を最初に与えなくて良いのですが、この他にも、K-meansの拡張版であるX-meansでもBIC（ベイズ情報量）を用いてクラスタ数を決定する方法もあります。 DBSCANの実装はそう難しくなかったのですが、HDBSCANの理解・実装に時間がかかったので、備忘録として残します。","category":"page"},{"location":"MachineLearning/HDBSCAN/#HDBSCANのアルゴリズム","page":"HDBSCAN","title":"HDBSCANのアルゴリズム","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"ほぼ、参考文献に載せた論文の2.2.2の文章を和訳したものです。","category":"page"},{"location":"MachineLearning/HDBSCAN/#中心距離の定義","page":"HDBSCAN","title":"中心距離の定義","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"このアルゴリズムには、対象となるデータの他に、２つのパラメータが必要となります。 １つ目のパラメータは距離の算出に使用する最小のポイントの数kです。もう一つは、クラスタの形成に必要な最小のクラスタサイズmin_clustersです。 最初のステップはデータ同士の距離を求めることです。まず、それぞれの点について中心距離を定義します。中心距離は、「ある点からk番目に近い点からの距離」として定義されます。","category":"page"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"この中心距離を用いて、相互到達可能距離(mutual reachability distance)と呼ばれる新しい測定基準が計算できます。相互到達可能距離は、2点それぞれの中心距離と2点間の距離（ユークリッド距離）の最大値です。","category":"page"},{"location":"MachineLearning/HDBSCAN/#最小全域木","page":"HDBSCAN","title":"最小全域木","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"次に、相互到達可能距離はデータ点を頂点として持ち、どの2点の間のエッジも相互到達可能距離の重みを持つグラフを作成するのに使用できます。これは計算する必要のあるグラフの最小全域木なので、アルゴリズムの人工的な概念に過ぎません。最小全域木とは全域木のエッジの重みの合計が最小になるものです。 つまり、最小全域木は閉路を持たず、エッジの重みの合計が最小となる完全なグラフに含まれるエッジによってすべてのノードが連結されたものです。結果の最小全域木は各点の中心距離を重みとするループ（self-edge,loopとも呼ばれます）を各頂点に加えることで変更されます。これにより拡張最小全域木と呼ばれるものが得られます。","category":"page"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"これで、グラフを使用してHDBSCAN階層を構築できます。 まず、クラスターラベルが1つあり、すべてのポイントがこのクラスターに割り当てられます。 このクラスターはクラスターリストに追加されます。 次に、グラフはエッジの重みで昇順で並べ替えられます。グラフの下から順に、拡張された最小全域木からエッジが繰り返し削除されます。同じ重みのエッジも同時に削除する必要があります。削除されるエッジの重み値は、現在の階層レベルを示すために使用されます。エッジが削除されると、削除されたエッジを含むクラスターが探索されます。切断され、 min_sizeより少ないポイントを含むクラスターには、すべてノイズラベルが割り当てられます。 切断されたがmin_sizeポイントを超えるクラスターには、新しいクラスターラベルが割り当てられます。 これはクラスター分割と呼ばれます。更に、新しいクラスタはクラスタのリストに追加されます。エッジの削除によるクラスタ分割が原因で新たなクラスタが生成された時に、新たな階層レベルが作られます。最終的には、データセットに含まれるすべてのデータがノイズに割り振られます。このような過程によって作られた階層がHDBSCAN階層です。HDBSCAN階層を作成する間、すべてのクラスタは保持され、それぞれの親クラスタへの参照を持っています。","category":"page"},{"location":"MachineLearning/HDBSCAN/#クラスタの識別","page":"HDBSCAN","title":"クラスタの識別","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"次のステップでは、HDBSCAM階層と作成されたクラスタのリストを使って特徴的なクラスタを階層の中から識別することです。これを行うには、クラスタの安定性を決定するのに使うことのできる新たな基準が確立される必要があります。これはラムダと呼ばれ、lambda = frac1edgeweightというものです。更に、クラスタにもlambda_birthとlambda_deathをそれぞれクラスタが生成された時のラムダ、そのクラスタが2つのクラスタに分割された際のラムダとして定義します。クラスタ内のそれぞれの点には、その点がクラスタから落ちた時のラムダをlambda_pとして定義できます。これで安定性をクラスタに対して計算することができます。このように表現できます。","category":"page"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"stability = sum_p in Cluster(lambda_p - lambda_birth)","category":"page"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"この安定性はクラスタを通して伝播される必要があります。末端のクラスタは子クラスタを持たず、クラスタのリストから識別することができます。末端のクラスタから始めてクラスタの持つ参照を用いて上の階層のクラスタへと移って行きます。末端のクラスタは常にその安定性を親クラスタに伝播するともに伝搬された子クラスたとして親クラスタに追加します。末端でないクラスタには2つのうちどちらかが起こります。もし処理中のクラスタの安定性が子クラスタの合計安定性より高い場合、その安定性だけが親クラスタへ伝えられます。その他の場合、その子クラスタの安定性の合計が親クラスタに伝えられます。自明ですが、ルートクラスタでは親クラスタへの伝播は発生しません。 処理が終わると、ルートクラスタには安定性が最も高い子クラスタへの参照が含まれています。最も高い安定性を持つクラスタは最も特徴的なクラスタです。最も特徴的なクラスタの詳細とともにHDBSCAN階層を使用すると、各データポイントのクラスタ割当が高速に生成できます。","category":"page"},{"location":"MachineLearning/HDBSCAN/#最後に","page":"HDBSCAN","title":"最後に","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"大分複雑なので、「ん？」となるところも結構ありますが、なんとか理解できるかなって感じです。 難しいアルゴリズムではありますが、他の手法とは段違いにノイズに強いので役に立つものだと思います（けどHorseMLに実装するのはかなり骨が折れそう…）。","category":"page"},{"location":"MachineLearning/HDBSCAN/#参考文献","page":"HDBSCAN","title":"参考文献","text":"","category":"section"},{"location":"MachineLearning/HDBSCAN/","page":"HDBSCAN","title":"HDBSCAN","text":"An Implementation of the HDBSCAN* Clustering Algorithm\nHow HDBSCAN Works","category":"page"},{"location":"#Horse-Blog","page":"Home","title":"Horse Blog","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"このブログは、MommaWatasuが備忘録的な感じで自分で書いたプログラムとかについて適当に書いてます。 使ってる言語は","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia\nRust(習得中)\nPython\nその他愉快な仲間たち（HTML等々）","category":"page"},{"location":"","page":"Home","title":"Home","text":"って感じです。 機械学習とかOS開発とかゲームプログラミングとかをやってるので、参考になれば良いです（結構OS開発なんかは日本語の情報が少ないので、奮闘してます）。 なお、JuliaのDocumenter.jl使ってる影響でドキュメント調なのは気にしない。","category":"page"},{"location":"HorseOS/#HorseOS","page":"HorseOSとは","title":"HorseOS","text":"","category":"section"},{"location":"HorseOS/","page":"HorseOSとは","title":"HorseOSとは","text":"僕は何故か最初にプログラミングに使ったマシンがLinuxだったことで、Linux信者になり。ノートパソコンにもWIndowsを消してLinux Mint入れてるんですが。 Linuxを使ってると、Windowsを使うのに比べかなりメタなところが垣間見えます。そうして何度も見ているうちに、OSを作ってみたいという気持ちが湧いてきたので、作り始めました。 それと、このOS作りを行う上で非常に参考にさせていただいているMikan本はじめ多くの先人たちはCでOSを作ってるんですが、Rustは安全で書きやすいというのをよく目にするので、ちょうど低レイヤーということで、 Rustの習得も兼ねてやってます。","category":"page"},{"location":"HorseOS/","page":"HorseOSとは","title":"HorseOSとは","text":"そんなわけでかなり数少ないRust製のOSなので、そんなに大したものではないとはいえ、参考になれば幸いです。 なお、なにかHorseOSに関して、OS作りに関して聞きたいこと等あれば、お気軽にリポジトリのissueに日本語で構わないので書いてください。","category":"page"},{"location":"HorseOS/layermanager1/#グラフィックスの改良","page":"重ね合わせ処理","title":"グラフィックスの改良","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"この章ではグラフィックスの修正・改良をやっていこうと思います。","category":"page"},{"location":"HorseOS/layermanager1/#コンソールの改良","page":"重ね合わせ処理","title":"コンソールの改良","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"本ではやっていませんが、僕はあることが気になっていました。コンソールの挙動がおかしいのです。 今までデバッグのために配列とかをコンソールに出力していたのですが、画面サイズに比べてコンソールのサイズがやたらと小さい（実機だと更に違和感が増す）です。これは当然といえば当然で、今まではメモリ管理ができなかったゆえに固定長の配列でコンソールのサイズを規定せざるを得なかったわけです。 しかし、今は動的メモリ確保ができるようになったので、allocクレートのVecが使えます。これをつかってConsole構造を","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"#[derive(Debug, Clone)]\npub struct Console {\n    buffer: Vec<Vec<char>>,\n    size: (usize, usize),\n    fg_color: PixelColor,\n    bg_color: PixelColor,\n    pub cursor_row: usize,\n    cursor_column: usize,\n    buffer_row_offset: usize,\n}","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"この用に書き換えてあげることで、初期化の際にコンソールサイズも設定できるようになります。なお、Copyトレイトが消えているのは、VecがCopyトレイトを持っていないためで、代わりにCloneを使って初期化します。 ちなみに、他のファイルも同時にコミットしていますが、グラフィックス周りにいくつかバグがあったので直しておきました。","category":"page"},{"location":"HorseOS/layermanager1/#重ね合わせ処理","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"","category":"section"},{"location":"HorseOS/layermanager1/#処理の概要","page":"重ね合わせ処理","title":"処理の概要","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"重ね合わせ処理を行うためには、Window、Layer、LayerManagerが必要で、LayerManagerが複数のLayerを管理し、LayerはWindowを持つという構造をしています。Mikan本ではここでshared_ptrやらunique_ptrなどの見慣れぬポインタが登場しますが、とりあえず実装するだけなら何も考えずRustのスマートポインタを使えば済みます。というか、このとき初めて知りましたが、Rustのスマートポインタは種類も多く、コンパイラがunsafeブロックを使わない限りのすべての安全性を確保する一方、プログラマがデータ安全性を保証できる際はスマートポインタを使って処理することができます。","category":"page"},{"location":"HorseOS/layermanager1/#container_of","page":"重ね合わせ処理","title":"container_of","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"あと、もう一つ新たな工夫として登場するのが、Window構造体の中に含まれるPixelWriterからもとの構造体のポインタを取得するプログラムが登場します。Mikan本ではC++の*thisなるものを使っていますが、Rustにはたぶんそんなものはありません。そこで、同じく本でLinuxで採用されていると紹介されているcontainer_ofを実装することにしました。とりあえずコードを示しておきます。","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"macro_rules! container_of{\n    ($ptr: expr, $container: path, $field: ident) => {\n        unsafe {\n            let inner = $ptr as *const _;\n            let outer = &(*(0 as *const $container)).$field as *const _;\n            &*((inner as usize - outer as usize) as *const $container)\n        }\n    }\n}","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"みればなんとなく解ると思いますが、要は$ptrがフィールドのポインタで、$containerが0x0にあるときの$fieldのアドレス分を$ptrのときの$containerのアドレスが分かるという仕組みです。","category":"page"},{"location":"HorseOS/layermanager1/#レイヤーマネージャーの使用","page":"重ね合わせ処理","title":"レイヤーマネージャーの使用","text":"","category":"section"},{"location":"HorseOS/layermanager1/#レイヤマネージャーの共有","page":"重ね合わせ処理","title":"レイヤマネージャーの共有","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"しかし、レイヤーマネージャーも実装したことだし、やっと重ね合わせができるぞ！と思っていたのもつかの間、すぐに問題が発生しました。レイヤマネージャーをグローバルスコープで共有しようとすると、その要素であるFrameBufferInfoが持つポインタがスレッドセーフで無いため、Mutexなどで包むことができません。これを解決するため、少しポインタについて考えてみます。","category":"page"},{"location":"HorseOS/layermanager1/#ポインタとスレッドセーフ","page":"重ね合わせ処理","title":"ポインタとスレッドセーフ","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"まず、スレッドセーフについてですが、これはRustのトレイトでいうとSyncを持つ型がスレッドセーフな構造体です。これを言い換えると、「内部可変性を持つかどうか」ということになりますが、主にデータ競合が発生しなければスレッドセーフなわけです。Rustのドキュメントではその型の参照を共有したときにデータ競合・未定義動作が起こらないという説明がなされています。しかし、生ポインタというのはどう考えてもスレッドセーフではありません、なぜならポインタのアドレスが守られたところで、その指し示す先が変わっていないことまでは保証できないためです（多分）。","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"しかし、困ったことにフレームバッファへのポインタやいつどこに渡されるか分からないWindowのためのRcはどうしても使う必要があります。なので、頑張ってスレッドセーフに受け渡しができるように実装していきましょう。","category":"page"},{"location":"HorseOS/layermanager1/#FrameBufferInfoの改造","page":"重ね合わせ処理","title":"FrameBufferInfoの改造","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"こいつはもうしょうがないのでフレームバッファのアドレスをusizeで包んだラッパーを作りました。","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"/// thread-safe FrameBuffer used for Layer Manager\n#[derive(Copy, Clone, Debug, Default)]\npub struct TSFrameBuffer {\n    fb: usize\n}","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"後は、implで生ポインタと変換するコードさえ書いておけば一応動きます（毎度unsafeなコードを経由するのはなんか嫌ですが）。","category":"page"},{"location":"HorseOS/layermanager1/#RcからArcへ","page":"重ね合わせ処理","title":"RcからArcへ","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"これは、もともと用意されているものを使うだけで良いので手間はかかりません。Rcの何が悪かったかというと、あくまでただの変数でカウントを行っているために、スレッド感でカウントを行おうとすると、カウンタでデータ競合が起こる可能性があったのです。そこで、Arcではアトミック操作（不可分操作）と呼ばれる操作を行います。これがCPUの命令レベルで実装されており、複数のデータの読み書きを行うのを一つの処理のように扱い、その最中に割り込みが発生する（データ競合する）ことを防ぐ方法です。まあ、もちろんその分コストは増えるようですが、データの安全性を保証するためならしょうがないでしょう。","category":"page"},{"location":"HorseOS/layermanager1/#再びメモリの問題が","page":"重ね合わせ処理","title":"再びメモリの問題が","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"ここまでやって、もう動くだろと思いきや、2点問題があったために動きませんでした。また一つづつ直していきます（本当にメモリ周りはデバッグも面倒だし、早く安定してほしい）","category":"page"},{"location":"HorseOS/layermanager1/#メモリマネージャのバグ","page":"重ね合わせ処理","title":"メモリマネージャのバグ","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"このバグは本当にその使用に気づいていなかったのですが、どうやらRustでは型注釈をつけないと型変換後の型ではなく、自動で32ビットとなるようです。つまり、どんなコードがバグったかといいますと、メモリマネージャがビットマップの読み出しを行う際に、","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"... & (1 << bit_idx) as MapLineType","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"のように書いていました（左辺はusize）、今までは左辺の型に合わせてくれるだろうと思ってたのですが、1をu32として解釈していたため、bit_idx（0から63までの値）でシフト演算を行うと、オーバーフロー起こすことがあったようです。","category":"page"},{"location":"HorseOS/layermanager1/#USBアロケータ","page":"重ね合わせ処理","title":"USBアロケータ","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"前にカーネルがメモリに乗り切らなくなったときに原因として削除したメモリアロケータですが、どうやら今のアロケータの仕組みでは行かないようで、イベント処理の際にUSBのメモリアロケータが割り当てたメモリでエラーが起こります。そこで、もう面倒くさいので改めて同じシステムを作り、そこに今度は動的メモリアロケータからVecとして割り当てることにしました。ここで、最初は固定長配列をBoxで囲めばいいかなと思ったんですが、どうもBoxは以下のような性質を持っているようです。","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"確保下領域は必ず初期化する必要がある\n「一旦スタックにデータを確保した後に」ヒープにデータをコピーする","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"前者はいいのですが、後者はなぜそうなるのか正直良くわかりません。これのせいで結局スタックにデータを確保するので、もとのアロケータ同じようにOSをクラッシュさせてしまいます。一方のVecは直接メモリに割り当ててくれるようなので問題はありません。","category":"page"},{"location":"HorseOS/layermanager1/#コンソールの出力先の変更","page":"重ね合わせ処理","title":"コンソールの出力先の変更","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"コンソールはいままで直接フレームバッファに書き込んでいましたが、この後はWIndowに書き込む必要があります。しかし、ここで一つ問題なのが、WindowWriterをConsoleのnewに渡そうとすると、そのまま渡すことはCopyトレイトを実装すればできますが、これでは意味がありません。なぜならcontainer_ofを使っているために、WIndowWriterの参照そのものが重要なためです。ただし、container_ofのマクロで使っているのはあくまで参照であって、可変参照ではありません。そのため、冷静に考えればPixelWriterの実装を&mut selfから&selfに変えればいい話ですが、FrameBufferWriterはそうは行きません（また、2種類のPixelWriterが存在するので、トレイトを使ったほうが良いのも事実です）。","category":"page"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"したがって、ここはWindowWriterに別枠で実装を行ったほうが良いと判断しました。別にこれはConsoleに限った話ではなく、どうあがいても、Layerの保持するWindowのWindowWriterで書き込みを行う必要があることから、避けて通れない話です。","category":"page"},{"location":"HorseOS/layermanager1/#次の章へ","page":"重ね合わせ処理","title":"次の章へ","text":"","category":"section"},{"location":"HorseOS/layermanager1/","page":"重ね合わせ処理","title":"重ね合わせ処理","text":"とりあえず、ここまでやれば大体動きます。もちろん他にもいくつか修正しているので、このコミットを見てもらえればとりあえずレイヤマネージャが動いてるっぽいコードが見れます（まだいくつかヤバそうなところはありますが）。 というわけで、とりあえず次の章では木にせずに高速化などをやっていきたいと思います。 なお、ここで木にしないのにはもう一つ理由があり、最終的にはLinuxと同じく、スペシャルファイルを介してやり取りを行うWindowシステムを作ろうと考えているためです。つまりは、このコードは今後カーネルから切り離すつもりということです。","category":"page"}]
}

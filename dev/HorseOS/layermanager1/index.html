<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>重ね合わせ処理 · HorseBlog</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HorseBlog</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">MachineLearning</span><ul><li><a class="tocitem" href="../../MachineLearning/HDBSCAN/">HDBSCAN</a></li></ul></li><li><span class="tocitem">AGI</span><ul><li><a class="tocitem" href="../../AGI/">AGIについて</a></li><li><a class="tocitem" href="../../AGI/CorticalColumn/">大脳皮質</a></li></ul></li><li><span class="tocitem">FreeCraft</span><ul><li><a class="tocitem" href="../../FreeCraft/">最初に</a></li><li><a class="tocitem" href="../../FreeCraft/1st/">1回目</a></li></ul></li><li><span class="tocitem">HorseOS</span><ul><li><a class="tocitem" href="../">HorseOSとは</a></li><li><a class="tocitem" href="../mouse/">マウスを動かす</a></li><li><a class="tocitem" href="../memory/">メモリ管理</a></li><li class="is-active"><a class="tocitem" href>重ね合わせ処理</a><ul class="internal"><li><a class="tocitem" href="#コンソールの改良"><span>コンソールの改良</span></a></li><li><a class="tocitem" href="#重ね合わせ処理"><span>重ね合わせ処理</span></a></li><li><a class="tocitem" href="#レイヤーマネージャーの使用"><span>レイヤーマネージャーの使用</span></a></li><li><a class="tocitem" href="#再びメモリの問題が"><span>再びメモリの問題が</span></a></li><li><a class="tocitem" href="#コンソールの出力先の変更"><span>コンソールの出力先の変更</span></a></li><li><a class="tocitem" href="#次の章へ"><span>次の章へ</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">HorseOS</a></li><li class="is-active"><a href>重ね合わせ処理</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>重ね合わせ処理</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MommaWatasu/Blog/blob/master/src/HorseOS/layermanager1.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="グラフィックスの改良"><a class="docs-heading-anchor" href="#グラフィックスの改良">グラフィックスの改良</a><a id="グラフィックスの改良-1"></a><a class="docs-heading-anchor-permalink" href="#グラフィックスの改良" title="Permalink"></a></h1><p>この章ではグラフィックスの修正・改良をやっていこうと思います。</p><h2 id="コンソールの改良"><a class="docs-heading-anchor" href="#コンソールの改良">コンソールの改良</a><a id="コンソールの改良-1"></a><a class="docs-heading-anchor-permalink" href="#コンソールの改良" title="Permalink"></a></h2><p>本ではやっていませんが、僕はあることが気になっていました。コンソールの挙動がおかしいのです。 今までデバッグのために配列とかをコンソールに出力していたのですが、画面サイズに比べてコンソールのサイズがやたらと小さい（実機だと更に違和感が増す）です。これは当然といえば当然で、今まではメモリ管理ができなかったゆえに固定長の配列でコンソールのサイズを規定せざるを得なかったわけです。 しかし、今は動的メモリ確保ができるようになったので、allocクレートのVecが使えます。これをつかって<code>Console</code>構造を</p><pre><code class="nohighlight hljs">#[derive(Debug, Clone)]
pub struct Console {
    buffer: Vec&lt;Vec&lt;char&gt;&gt;,
    size: (usize, usize),
    fg_color: PixelColor,
    bg_color: PixelColor,
    pub cursor_row: usize,
    cursor_column: usize,
    buffer_row_offset: usize,
}</code></pre><p>この用に書き換えてあげることで、初期化の際にコンソールサイズも設定できるようになります。なお、<code>Copy</code>トレイトが消えているのは、<code>Vec</code>が<code>Copy</code>トレイトを持っていないためで、代わりに<code>Clone</code>を使って初期化します。 ちなみに、他のファイルも同時にコミットしていますが、グラフィックス周りにいくつかバグがあったので直しておきました。</p><h2 id="重ね合わせ処理"><a class="docs-heading-anchor" href="#重ね合わせ処理">重ね合わせ処理</a><a id="重ね合わせ処理-1"></a><a class="docs-heading-anchor-permalink" href="#重ね合わせ処理" title="Permalink"></a></h2><h3 id="処理の概要"><a class="docs-heading-anchor" href="#処理の概要">処理の概要</a><a id="処理の概要-1"></a><a class="docs-heading-anchor-permalink" href="#処理の概要" title="Permalink"></a></h3><p>重ね合わせ処理を行うためには、<code>Window</code>、<code>Layer</code>、<code>LayerManager</code>が必要で、<code>LayerManager</code>が複数の<code>Layer</code>を管理し、<code>Layer</code>は<code>Window</code>を持つという構造をしています。Mikan本ではここで<code>shared_ptr</code>やら<code>unique_ptr</code>などの見慣れぬポインタが登場しますが、とりあえず実装するだけなら何も考えずRustのスマートポインタを使えば済みます。というか、このとき初めて知りましたが、Rustのスマートポインタは種類も多く、コンパイラが<code>unsafe</code>ブロックを使わない限りのすべての安全性を確保する一方、プログラマがデータ安全性を保証できる際はスマートポインタを使って処理することができます。</p><h3 id="container_of"><a class="docs-heading-anchor" href="#container_of"><code>container_of</code></a><a id="container_of-1"></a><a class="docs-heading-anchor-permalink" href="#container_of" title="Permalink"></a></h3><p>あと、もう一つ新たな工夫として登場するのが、<code>Window</code>構造体の中に含まれる<code>PixelWriter</code>からもとの構造体のポインタを取得するプログラムが登場します。Mikan本ではC++の<code>*this</code>なるものを使っていますが、Rustにはたぶんそんなものはありません。そこで、同じく本でLinuxで採用されていると紹介されている<code>container_of</code>を実装することにしました。とりあえずコードを示しておきます。</p><pre><code class="nohighlight hljs">macro_rules! container_of{
    ($ptr: expr, $container: path, $field: ident) =&gt; {
        unsafe {
            let inner = $ptr as *const _;
            let outer = &amp;(*(0 as *const $container)).$field as *const _;
            &amp;*((inner as usize - outer as usize) as *const $container)
        }
    }
}</code></pre><p>みればなんとなく解ると思いますが、要は<code>$ptr</code>がフィールドのポインタで、<code>$container</code>が<code>0x0</code>にあるときの<code>$field</code>のアドレス分を<code>$ptr</code>のときの<code>$container</code>のアドレスが分かるという仕組みです。</p><h2 id="レイヤーマネージャーの使用"><a class="docs-heading-anchor" href="#レイヤーマネージャーの使用">レイヤーマネージャーの使用</a><a id="レイヤーマネージャーの使用-1"></a><a class="docs-heading-anchor-permalink" href="#レイヤーマネージャーの使用" title="Permalink"></a></h2><h3 id="レイヤマネージャーの共有"><a class="docs-heading-anchor" href="#レイヤマネージャーの共有">レイヤマネージャーの共有</a><a id="レイヤマネージャーの共有-1"></a><a class="docs-heading-anchor-permalink" href="#レイヤマネージャーの共有" title="Permalink"></a></h3><p>しかし、レイヤーマネージャーも実装したことだし、やっと重ね合わせができるぞ！と思っていたのもつかの間、すぐに問題が発生しました。レイヤマネージャーをグローバルスコープで共有しようとすると、その要素である<code>FrameBufferInfo</code>が持つポインタがスレッドセーフで無いため、<code>Mutex</code>などで包むことができません。これを解決するため、少しポインタについて考えてみます。</p><h3 id="ポインタとスレッドセーフ"><a class="docs-heading-anchor" href="#ポインタとスレッドセーフ">ポインタとスレッドセーフ</a><a id="ポインタとスレッドセーフ-1"></a><a class="docs-heading-anchor-permalink" href="#ポインタとスレッドセーフ" title="Permalink"></a></h3><p>まず、スレッドセーフについてですが、これはRustのトレイトでいうと<code>Sync</code>を持つ型がスレッドセーフな構造体です。これを言い換えると、「内部可変性を持つかどうか」ということになりますが、主にデータ競合が発生しなければスレッドセーフなわけです。Rustのドキュメントではその型の参照を共有したときにデータ競合・未定義動作が起こらないという説明がなされています。しかし、生ポインタというのはどう考えてもスレッドセーフではありません、なぜならポインタのアドレスが守られたところで、その指し示す先が変わっていないことまでは保証できないためです（多分）。</p><p>しかし、困ったことにフレームバッファへのポインタやいつどこに渡されるか分からない<code>Window</code>のための<code>Rc</code>はどうしても使う必要があります。なので、頑張ってスレッドセーフに受け渡しができるように実装していきましょう。</p><h3 id="FrameBufferInfoの改造"><a class="docs-heading-anchor" href="#FrameBufferInfoの改造">FrameBufferInfoの改造</a><a id="FrameBufferInfoの改造-1"></a><a class="docs-heading-anchor-permalink" href="#FrameBufferInfoの改造" title="Permalink"></a></h3><p>こいつはもうしょうがないのでフレームバッファのアドレスを<code>usize</code>で包んだラッパーを作りました。</p><pre><code class="nohighlight hljs">/// thread-safe FrameBuffer used for Layer Manager
#[derive(Copy, Clone, Debug, Default)]
pub struct TSFrameBuffer {
    fb: usize
}</code></pre><p>後は、<code>impl</code>で生ポインタと変換するコードさえ書いておけば一応動きます（毎度<code>unsafe</code>なコードを経由するのはなんか嫌ですが）。</p><h3 id="RcからArcへ"><a class="docs-heading-anchor" href="#RcからArcへ"><code>Rc</code>から<code>Arc</code>へ</a><a id="RcからArcへ-1"></a><a class="docs-heading-anchor-permalink" href="#RcからArcへ" title="Permalink"></a></h3><p>これは、もともと用意されているものを使うだけで良いので手間はかかりません。<code>Rc</code>の何が悪かったかというと、あくまでただの変数でカウントを行っているために、スレッド感でカウントを行おうとすると、カウンタでデータ競合が起こる可能性があったのです。そこで、<code>Arc</code>ではアトミック操作（不可分操作）と呼ばれる操作を行います。これがCPUの命令レベルで実装されており、複数のデータの読み書きを行うのを一つの処理のように扱い、その最中に割り込みが発生する（データ競合する）ことを防ぐ方法です。まあ、もちろんその分コストは増えるようですが、データの安全性を保証するためならしょうがないでしょう。</p><h2 id="再びメモリの問題が"><a class="docs-heading-anchor" href="#再びメモリの問題が">再びメモリの問題が</a><a id="再びメモリの問題が-1"></a><a class="docs-heading-anchor-permalink" href="#再びメモリの問題が" title="Permalink"></a></h2><p>ここまでやって、もう動くだろと思いきや、2点問題があったために動きませんでした。また一つづつ直していきます（本当にメモリ周りはデバッグも面倒だし、早く安定してほしい）</p><h3 id="メモリマネージャのバグ"><a class="docs-heading-anchor" href="#メモリマネージャのバグ">メモリマネージャのバグ</a><a id="メモリマネージャのバグ-1"></a><a class="docs-heading-anchor-permalink" href="#メモリマネージャのバグ" title="Permalink"></a></h3><p>このバグは本当にその使用に気づいていなかったのですが、どうやらRustでは型注釈をつけないと型変換後の型ではなく、自動で32ビットとなるようです。つまり、どんなコードがバグったかといいますと、メモリマネージャがビットマップの読み出しを行う際に、</p><pre><code class="nohighlight hljs">... &amp; (1 &lt;&lt; bit_idx) as MapLineType</code></pre><p>のように書いていました（左辺は<code>usize</code>）、今までは左辺の型に合わせてくれるだろうと思ってたのですが、1を<code>u32</code>として解釈していたため、<code>bit_idx</code>（0から63までの値）でシフト演算を行うと、オーバーフロー起こすことがあったようです。</p><h3 id="USBアロケータ"><a class="docs-heading-anchor" href="#USBアロケータ">USBアロケータ</a><a id="USBアロケータ-1"></a><a class="docs-heading-anchor-permalink" href="#USBアロケータ" title="Permalink"></a></h3><p>前にカーネルがメモリに乗り切らなくなったときに原因として削除したメモリアロケータですが、どうやら今のアロケータの仕組みでは行かないようで、イベント処理の際にUSBのメモリアロケータが割り当てたメモリでエラーが起こります。そこで、もう面倒くさいので改めて同じシステムを作り、そこに今度は動的メモリアロケータから<code>Vec</code>として割り当てることにしました。ここで、最初は固定長配列を<code>Box</code>で囲めばいいかなと思ったんですが、どうも<code>Box</code>は以下のような性質を持っているようです。</p><ul><li>確保下領域は必ず初期化する必要がある</li><li>「一旦スタックにデータを確保した後に」ヒープにデータをコピーする</li></ul><p>前者はいいのですが、後者はなぜそうなるのか正直良くわかりません。これのせいで結局スタックにデータを確保するので、もとのアロケータ同じようにOSをクラッシュさせてしまいます。一方のVecは直接メモリに割り当ててくれるようなので問題はありません。</p><h2 id="コンソールの出力先の変更"><a class="docs-heading-anchor" href="#コンソールの出力先の変更">コンソールの出力先の変更</a><a id="コンソールの出力先の変更-1"></a><a class="docs-heading-anchor-permalink" href="#コンソールの出力先の変更" title="Permalink"></a></h2><p>コンソールはいままで直接フレームバッファに書き込んでいましたが、この後は<code>WIndow</code>に書き込む必要があります。しかし、ここで一つ問題なのが、<code>WindowWriter</code>を<code>Console</code>の<code>new</code>に渡そうとすると、そのまま渡すことは<code>Copy</code>トレイトを実装すればできますが、これでは意味がありません。なぜなら<code>container_of</code>を使っているために、<code>WIndowWriter</code>の参照そのものが重要なためです。ただし、<code>container_of</code>のマクロで使っているのはあくまで参照であって、可変参照ではありません。そのため、冷静に考えれば<code>PixelWriter</code>の実装を<code>&amp;mut self</code>から<code>&amp;self</code>に変えればいい話ですが、<code>FrameBufferWriter</code>はそうは行きません（また、2種類の<code>PixelWriter</code>が存在するので、トレイトを使ったほうが良いのも事実です）。</p><p>したがって、ここは<code>WindowWriter</code>に別枠で実装を行ったほうが良いと判断しました。別にこれは<code>Console</code>に限った話ではなく、どうあがいても、<code>Layer</code>の保持する<code>Window</code>の<code>WindowWriter</code>で書き込みを行う必要があることから、避けて通れない話です。</p><h2 id="次の章へ"><a class="docs-heading-anchor" href="#次の章へ">次の章へ</a><a id="次の章へ-1"></a><a class="docs-heading-anchor-permalink" href="#次の章へ" title="Permalink"></a></h2><p>とりあえず、ここまでやれば大体動きます。もちろん他にもいくつか修正しているので、<a href="https://github.com/MommaWatasu/Horse/commit/6cc9c733fb99c55a1e0eb8c972c479949ce09ba1">このコミット</a>を見てもらえればとりあえずレイヤマネージャが動いてるっぽいコードが見れます（まだいくつかヤバそうなところはありますが）。 というわけで、とりあえず次の章では木にせずに高速化などをやっていきたいと思います。 なお、ここで木にしないのにはもう一つ理由があり、最終的にはLinuxと同じく、スペシャルファイルを介してやり取りを行うWindowシステムを作ろうと考えているためです。つまりは、このコードは今後カーネルから切り離すつもりということです。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../memory/">« メモリ管理</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 27 March 2023 14:54">Monday 27 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

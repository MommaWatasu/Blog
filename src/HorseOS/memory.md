# メモリ管理ぐらいまで

## ブートローダーの修正
uefi-rsのドキュメントを見ていて気づきました。他の人がだいぶ前に作ったOSのCargo.tomlを見ていたので、uefi-rsのバージョンがかなり古くなっていました。
古いものを使い続けるのは厄介なので、ここでコードのリファクタリングも兼ねてブートローダーをuefi-rs18.0を使って書き直しました。
ついでに、yubrotさんのorsを参考に、ELFのロード方法なども変更しました。

## メモリ管理
正直、ここは割と作業なので、あんまり考える余地がないので、できてるものをコピるのが早いと思います。
というわけで、メモリ管理は完成〜としたいところでしたが、なぜか動きません。正確には実機ではちゃんと起動してくれるのですが、QEMUで実行するとフリーズします。

### エントリポイントの修正
これの原因究明にはかなり時間を使いましたが、メモリマップとブートローダを見直した結果わかりました。
おそらく（解決後もはっきりとは分かってない）カーネルのベースアドレスを指定していなかったために、後ろの方のアドレスにカーネルが配置されてしまい、他のシステムが使うメモリを破壊してしまったようです。
なので、少し気持ち悪いですが、Rustのターゲットファイル`x86_64-unknown-none-horsekernel.json`にある`post-link-args`でイメージのベースアドレスを指定するオプションを追加します。
こんな感じです：
```
...
"post-link-args": {
    "ld": [
        ...
        "--image-base=0x100000"
        ...
    ]
}
...
```
正直、未だにこのターゲットファイルのそれぞれのパラメータの意味が理解できていません。そろそろなんとかしたいな…
では、再度実行してみましょう。どうなったでしょうか？多分相変わらずフリーズします。さっきの設定で追加で0x100000~0x200000が使えるようになったのは事実なんですが、それでもカーネルのプログラムサイズが0xa00000もあるので、メモリマップの都合上収まりません。
更に、確認のためyubrotさんのorsを実行して確認したところ、本来のカーネルサイズは0x700000ほどなようなので、なにか他のプログラムに問題があるようです。
ここまで来るとELFのファイル構造を勉強したほうがいいと思ったので、一度ここで説明しようと思います。

### ELFファイルの構造
ELFファイルは主に3つの部分からなります。以下のような構造です。
```
+----------------+
|   ELF Header   |
+----------------+
| Program Header0|
| Program Header1|
|       :　　　　 |
+----------------+
|    Segment0    |
|    Segment1    |
|       :　　　　 |
+----------------+
```
HorseOSのブートローダーは現状goblinというRustのクレートにELFファイルの解析を丸投げしてますが、本来は先頭にあるELFヘッダからELFのメタデータを取得した後、プログラムから各セグメントに対応する（つまり、プログラムヘッダはセグメントと同数存在する）情報を取得し、これをもとにメモリのどこにプログラムをロードするかを決定します。
そして、それぞれのセグメントについてですが、セグメントは主に
- コードセグメント
- データセグメント

の2種類があります。その名と通りコードセグメントはプログラムがマシン語で記述されており、データセグメントはプログラムが使用するデータ（staticやconstで宣言された変数）を保持しています。

### 原因のデータ
先程のELFの構造が分かった上で、ブートローダでファイル経由でELFのプログラムヘッダの情報を表示してみました。
```
start: 1048576, end: 1104092
start: 1108192, end: 1441923
start: 1446024, end: 1446032
start: 1454080, end: 11190352
start address is: 00100000
end address is: 00aac050
kernel_size: 009ac050
```
これは僕が実際にデバッグするために表示したデータです（どこに原因があるのかわからず余計な情報も表示しています）。そして、これをメモリマネージャなしの状態で表示すると
```
start: 1048576, end: 1103260
start: 1107360, end: 1436739
start: 1440840, end: 1440848
start: 1445888, end: 6987856
start address is: 00100000
end address is: 006aa050
kernel_size: 005aa050
```
おわかりでしょうか？明らかに最後のセグメントのデータ数だけ大きく差があり、また一番データを食ってるのも一番最後のセグメントです。つまり、おそらく最後のセグメントがデータセグメントとなっています。載せるのが面倒なので書きませんが、orsでこれを確認すると、更にデータセグメントの部分が少なくなっています。しかも、興味深いことにちょうどBitmapFrameManagerと同じだけ！後は片っ端からカーネルで宣言されているグローバル変数を確かめていくだけです。
すると、なんとなく察していましたが、USB用にメモリアロケータを作成していることに気づきました。こちらは4MB分のメモリアロケータを実装していたため、BitmapFrameManagerのビットマップと同じだけ消費していたようです。
ここまでわかれば後はこいつを新しく実装した動的アロケータで置き換えればいいわけです。めでたしめでたし。
次回からはようやくウィンドウなんかの実装へと移ります！